\documentclass[../main.tex]{subfiles}
\begin{document}
\chapter{Protokol Kriptografi}

\section{Protokol Komunikasi dengan Sistem Kriptografi Simetri}
Protokol berbasis kunci simetri membutuhkan mekanisme distribusi kunci yang aman, seringkali melalui kanal sebelumnya atau infrastruktur terpusat. Desain protokol harus menangani sinkronisasi, manajemen nonce, dan integritas pesan. Kesalahan desain seperti reuse nonce dapat menghancurkan keamanan.

Model ancaman harus mempertimbangkan penyerang aktif dan pasif untuk menetapkan mekanisme perlindungan yang sesuai.

\section{Protokol Komunikasi dengan Sistem Kriptografi Kunci Publik}
Kunci publik memungkinkan negosiasi kunci sesi melalui saluran publik dan otentikasi identitas melalui sertifikat. Desain protokol harus mencakup validasi sertifikat, pengecekan status pencabutan, dan perlindungan terhadap downgrade. Integrasi dengan PKI menambah kompleksitas tetapi meningkatkan skalabilitas.

Contoh konkret dapat ditemukan pada protokol TLS modern \parencite{rfc8446}.

\begin{table}[h]
\centering
\caption{Ringkasan beberapa protokol}
\label{tab:protokol}
\begin{tabular}{lll}
\toprule
Protokol & Tujuan & Catatan \\
\midrule
TLS 1.3 & Saluran aman & Forward secrecy, AEAD \parencite{rfc8446} \\
Kerberos & Otentikasi jaringan & Tiket berbasis kunci simetri \parencite{rfc4120} \\
Signal (X3DH+DR) & Pesan aman end-to-end & Forward secrecy, post-compromise security \parencite{signal-dr,x3dh} \\
\bottomrule
\end{tabular}
\end{table}

\section{Protokol untuk Tanda-tangan Digital}
Protokol tanda tangan menyertakan mekanisme pengikatan konteks, penandatanganan data, dan verifikasi oleh pihak penerima. Desain harus mencegah pemutaran ulang dan ambiguitas data yang ditandatangani. Pengelolaan kunci yang baik dan audit menjadi elemen penting.

Standar format tanda tangan dan pengodean data membantu interoperabilitas antar sistem.

\section{Protokol untuk Tanda-tangan Digital Plus Enkripsi}
Kombinasi tanda tangan dan enkripsi harus memperhatikan urutan operasi untuk mencapai sifat keamanan yang diinginkan. Tanda tangan-lalu-enkripsi dan enkripsi-lalu-tanda tangan memiliki implikasi keamanan dan privasi yang berbeda. Pilihan harus didasarkan pada model ancaman dan kebutuhan aplikasi.

Literatur terbuka membahas skema yang mengintegrasikan keduanya dengan keamanan terbukti.

\section{Protokol Pertukaran Kunci Diffie-Hellman}
Protokol Diffie--Hellman memerlukan validasi parameter dan proteksi terhadap serangan man-in-the-middle melalui autentikasi. Versi modern menggabungkan ephemeral keys untuk mencapai forward secrecy. Detail implementasi memengaruhi keamanan secara signifikan.

TLS 1.3 mengilustrasikan praktik terbaik dalam perancangan protokol pertukaran kunci \parencite{rfc8446}.

\begin{figure}[h]
\centering
\begin{tikzpicture}[node distance=0.8cm, >=Latex]
  \node (c) {Client};
  \node (s) [right=5.5cm of c] {Server};
  \draw[->] (c) -- node[above]{ClientHello (key\_share, SNI)} (s);
  \draw[->] (s) -- node[below]{ServerHello (key\_share), EncryptedExtensions, Certificate, Finished} (c);
  \draw[->] (c) -- node[above]{Finished} (s);
\end{tikzpicture}
\caption{Skema ringkas handshake TLS 1.3.}
\label{fig:tls13}
\end{figure}

\section{Otentikasi}
Otentikasi memastikan identitas entitas sebelum melanjutkan pertukaran data sensitif. Skema dapat berbasis kata sandi, token, atau kunci publik, masing-masing dengan tantangan keamanan yang khas. Mekanisme harus tahan terhadap phishing, replay, dan brute-force.

Desain sistem sering memanfaatkan multi-faktor untuk meningkatkan jaminan identitas.

\section{Secure Socket Layer (SSL)}
SSL/TLS menyediakan saluran aman di atas TCP dengan negosiasi kriptografi, autentikasi, dan integritas. Evolusi ke TLS 1.3 menyederhanakan suite kriptografi dan menguatkan keamanan. Implementasi harus selalu mengikuti praktik terbaru dan menonaktifkan versi lama yang rentan.

Spesifikasi \textcite{rfc8446} memberikan rujukan utama untuk penerapan modern.

\subsection{Contoh Kode: TLS Client Sederhana}
Contoh berikut membuka koneksi TLS menggunakan modul standar Python.

\begin{lstlisting}[language=Python, caption={TLS client}, label={lst:tls-client}]
import socket, ssl

context = ssl.create_default_context()
with socket.create_connection(("example.com", 443)) as sock:
    with context.wrap_socket(sock, server_hostname="example.com") as ssock:
        ssock.sendall(b"GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")
        print(ssock.recv(1024))
\end{lstlisting}

\end{document}
